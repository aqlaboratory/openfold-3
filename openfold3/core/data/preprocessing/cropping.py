# TODO add license

from typing import Optional, Union

import numpy as np
from biotite.structure import Atom, AtomArray
from numpy.random import Generator
from scipy.spatial.distance import cdist

from openfold3.core.data.preprocessing.structure_primitives import get_interface_atoms


def crop_contiguous(
    atom_array: AtomArray, token_budget: int, generator: Generator
) -> None:
    """Implements Contiguous Cropping from AF3 SI, 2.7.1.

    Uses Algorithm 1 from AF-Multimer section 7.2.1. to update the input biotite
    atom array with added 'af3_crop_mask' annotation in-place. Note: Algorithm 1
    does not work correctly as stated in the AF-Multimer SI, so here we are using
    a fixed version.

    Args:
        atom_array (atom_array):
            Biotite atom array of the first bioassembly of a PDB entry.
        token_budget (int):
            Token budget i.e. total crop size.
        generator (Generator):
            A numpy generator set with a specific seed.

    Returns:
        None
    """

    # Get chain ids and permute
    chains = np.array(list(set(atom_array.af3_chain_id)), dtype=int)
    chains = generator.permutation(chains)

    # Create cropping mask annotation
    atom_array.set_annotation("af3_crop_mask", np.repeat(False, len(atom_array)))

    # Cropping loop
    tokens_remaining = max(atom_array.af3_token_id)

    for chain_id in chains:
        # Get chain atom array
        atom_array_chain = atom_array[atom_array.af3_chain_id == chain_id]

        # Get chain length
        chain_length = (
            atom_array_chain.af3_token_id[-1] - atom_array_chain.af3_token_id[0] + 1
        )
        tokens_remaining -= chain_length

        # Sample length of crop for current chain
        crop_size_max = min(token_budget, chain_length)
        crop_size_min = min(chain_length, max(0, token_budget - tokens_remaining))
        crop_size = generator.integers(crop_size_min, crop_size_max + 1, 1).item()

        token_budget -= crop_size

        crop_start = generator.integers(0, chain_length - crop_size, 1).item()
        crop_start_global = atom_array_chain[crop_start].af3_atom_id

        # Edit corresponding segment in crop mask
        atom_array.af3_crop_mask[crop_start_global : crop_start_global + crop_size] = (
            True
        )

        if token_budget == 0:
            break

    return None


def crop_spatial(
    atom_array: AtomArray,
    token_budget: int,
    generator: Generator,
    preferred_chain_or_interface: Optional[Union[int, tuple[int, int]]] = None,
) -> None:
    """Implements Spatial Cropping from AF3 SI, 2.7.2.

    Uses Algorithm 2 from AF-Multimer section 7.2.2. to update the input biotite
    atom array with added 'af3_crop_mask' annotation in-place. Note: we drop the
    index-based distance-untying step from Algorithm 2 (line 1, i * 10^-3 factor)
    because it distorts the distances and results in less convex spatial crops.

    Args:
        atom_array (AtomArray):
            Biotite atom array of the first bioassembly of a PDB entry.
        token_budget (int):
            Total crop size.
        generator (Generator):
            A numpy generator set with a specific seed.
        preferred_chain_or_interface (Optional[Union[int, tuple[int, int]]]):
            Integer or integer 2-tuple indicating the preferred chain or interface,
            respectively, from which reference atoms are selected. Generated by
            eq. 1 in AF3 SI for the weighted PDB dataset.

    Returns:
        None
    """
    # Subset token center atoms to those in the preferred chain/interface if provided
    token_center_atoms, preferred_token_center_atoms = subset_preferred(
        atom_array, preferred_chain_or_interface
    )

    # Get reference atom
    reference_atom = generator.choice(preferred_token_center_atoms, size=1)[0]

    # Find spatial crop
    find_spatial_crop(reference_atom, token_center_atoms, token_budget, atom_array)

    return None


def crop_spatial_interface(
    atom_array: AtomArray,
    token_budget: int,
    generator: Generator,
    preferred_chain_or_interface: Optional[Union[int, tuple[int, int]]] = None,
) -> None:
    """Implements Spatial Interface Cropping from AF3 SI, 2.7.3.

    Uses Algorithm 2 from AF-Multimer section 7.2.2. to update the input biotite
    atom array with added 'af3_crop_mask' annotation in-place. Note: we drop the
    index-based distance-untying step from Algorithm 2 (line 1, i * 10^-3 factor)
    because it distorts the distances and results in less convex spatial crops.

    Args:
        atom_array (AtomArray):
            Biotite atom array of the first bioassembly of a PDB entry.
        token_budget (int):
            Total crop size.
        generator (Generator):
            A numpy generator set with a specific seed.
        preferred_chain_or_interface (Optional[Union[int, tuple[int, int]]]):
            Integer or integer 2-tuple indicating the preferred chain or interface,
            respectively, from which reference atoms are selected. Generated by
            eq. 1 in AF3 SI for the weighted PDB dataset.

    Returns:
        None
    """
    # Subset token center atoms to those in the preferred chain/interface if provided
    token_center_atoms, preferred_token_center_atoms = subset_preferred(
        atom_array, preferred_chain_or_interface
    )

    # Find interface token center atoms
    preferred_interface_token_center_atoms = get_interface_atoms(
        preferred_token_center_atoms, token_center_atoms
    )

    # Get reference atom
    reference_atom = generator.choice(preferred_interface_token_center_atoms, size=1)[0]

    # Find spatial crop
    find_spatial_crop(reference_atom, token_center_atoms, token_budget, atom_array)

    return None


def subset_preferred(
    atom_array: AtomArray,
    preferred_chain_or_interface: Optional[Union[int, tuple[int, int]]],
) -> tuple[AtomArray, AtomArray]:
    """Subsets token center atoms to those in the preferred chain or interface.

    Args:
        atom_array (AtomArray):
            AtomArray of the input assembly.
        preferred_chain_or_interface (Optional[Union[int, tuple[int, int]]]):
            Integer or integer 2-tuple indicating the preferred chain or interface,
            respectively, from which reference atoms are selected. Generated by eq. 1 in
            AF3 SI for the weighted PDB dataset.

    Raises:
        ValueError:
            Invalid preferred_chain_or_interface: {preferred_chain_or_interface}, has to
            be int or tuple.

    Returns:
        tuple[AtomArray, AtomArray]:
            Tuple of all and preferred token center atoms.
    """
    token_center_atoms = atom_array[atom_array.af3_token_center_atom]
    if preferred_chain_or_interface is not None:
        # If chain provided
        if isinstance(preferred_chain_or_interface, int):
            preferred_token_center_atoms = token_center_atoms[
                token_center_atoms.af3_chain_id == preferred_chain_or_interface
            ]
        # If interface provided
        elif isinstance(preferred_chain_or_interface, tuple):
            preferred_token_center_atoms = token_center_atoms[
                np.isin(token_center_atoms.af3_chain_id, preferred_chain_or_interface)
            ]
        else:
            raise ValueError(
                f"""Invalid preferred_chain_or_interface: \
                 {preferred_chain_or_interface}, has to be int or tuple."""
            )
    else:
        preferred_token_center_atoms = token_center_atoms
    return token_center_atoms, preferred_token_center_atoms


def find_spatial_crop(
    reference_atom: Atom,
    token_center_atoms: AtomArray,
    token_budget: int,
    atom_array: AtomArray,
) -> None:
    """Finds the token_budget number of closes atoms to the reference atom.

    Args:
        reference_atom (Atom):
            The sampled reference atom around which the spatial crop is created.
        token_center_atoms (AtomArray):
            The set of token center atoms to crop from.
        token_budget (int):
            Crop size.
        atom_array (AtomArray):
            Input atom array of the bioassembly.

    Returns:
        None
    """
    # Get distance from all other token center atoms and break ties
    distances_to_reference_atom = cdist(
        np.reshape(reference_atom.coord, (1, -1)), token_center_atoms.coord
    )[0, :]

    # Get token_budget nearest token center atoms
    nearest_token_center_atom_ids = np.argsort(distances_to_reference_atom)[
        :token_budget
    ]

    # Get all atoms for nearest token center atoms
    atom_array.set_annotation(
        "af3_crop_mask",
        np.isin(
            atom_array.af3_token_id,
            token_center_atoms[nearest_token_center_atom_ids].af3_token_id,
        ),
    )
    return None
